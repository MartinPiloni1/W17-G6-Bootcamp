package repository

import (
	"context"
	"database/sql"
	"errors"

	"github.com/aaguero_meli/W17-G6-Bootcamp/internal/models"
	"github.com/aaguero_meli/W17-G6-Bootcamp/pkg/httperrors"
	"github.com/go-sql-driver/mysql"
)

type BuyerRepositoryDB struct {
	db *sql.DB
}

// Generates a repository with the db connection as parameter
func NewBuyerRepositoryDB(db *sql.DB) *BuyerRepositoryDB {
	return &BuyerRepositoryDB{db: db}
}

// Create inserts a new Buyer into the database.
//
// Returns the created Buyer with its generated ID, or an error if the operation fails.
func (r *BuyerRepositoryDB) Create(ctx context.Context, newBuyer models.BuyerAttributes) (models.Buyer, error) {
	query := `
		INSERT INTO 
			buyers (card_number_id, first_name, last_name)
		VALUES (?, ?, ?)
	`

	result, err := r.db.ExecContext(
		ctx,
		query,
		newBuyer.CardNumberId,
		newBuyer.FirstName,
		newBuyer.LastName,
	)
	if err != nil {
		if mysqlErr, ok := err.(*mysql.MySQLError); ok {
			if mysqlErr.Number == 1062 {
				// cardNumberId is unique
				return models.Buyer{}, httperrors.ConflictError{Message: "CardNumberId already in use"}
			}
		}
		return models.Buyer{}, err
	}

	// Obtain autogenerated Id
	lastID, err := result.LastInsertId()
	if err != nil {
		return models.Buyer{}, err
	}

	var buyer models.Buyer = models.Buyer{
		Id:              int(lastID),
		BuyerAttributes: newBuyer,
	}

	return buyer, nil
}

// GetAll retrieves all Buyers from the database with all the data for each one.
//
// Returns a slice of Buyers or an error if the query fails.
func (r *BuyerRepositoryDB) GetAll(ctx context.Context) ([]models.Buyer, error) {
	const query = `
        SELECT 
			b.id,
			b.first_name, 
			b.last_name, 
			b.card_number_id 
        FROM 
			buyers b
    `
	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	buyers := make([]models.Buyer, 0)
	for rows.Next() {

		var buyer models.Buyer
		err := rows.Scan(
			&buyer.Id,
			&buyer.FirstName,
			&buyer.LastName,
			&buyer.CardNumberId,
		)

		if err != nil {
			return nil, err
		}
		buyers = append(buyers, buyer)
	}

	err = rows.Err()
	if err != nil {
		return nil, err
	}
	return buyers, nil
}

// GetByID fetches a Buyer by its ID from the database.
//
// Returns the Buyer if found, or an error if not found or if a database error occurs.
func (r *BuyerRepositoryDB) GetByID(ctx context.Context, id int) (models.Buyer, error) {
	const query = `
		SELECT
			b.id,
			b.first_name, 
			b.last_name, 
			b.card_number_id
		FROM
			buyers b
		WHERE
			b.id = ?
	`
	row := r.db.QueryRowContext(ctx, query, id)

	var buyer models.Buyer
	err := row.Scan(&buyer.Id, &buyer.FirstName, &buyer.LastName, &buyer.CardNumberId)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return models.Buyer{}, httperrors.NotFoundError{Message: "Buyer not found"}
		}

		return models.Buyer{}, err
	}
	return buyer, nil
}

// modifies the Buyer with the given ID in the database using the provided updatedBuyer fields.
// Returns the updated Buyer if the operation is successful, or an error if the update fails.
func (r *BuyerRepositoryDB) Update(ctx context.Context, id int, updatedBuyer models.Buyer) (models.Buyer, error) {
	query := `
        UPDATE 
			buyers b
        SET 
			b.card_number_id = ?, 
			b.first_name = ?, 
			b.last_name = ?
        WHERE 
			b.id = ?
    `

	_, err := r.db.ExecContext(
		ctx,
		query,
		updatedBuyer.CardNumberId,
		updatedBuyer.FirstName,
		updatedBuyer.LastName,
		id,
	)
	if err != nil {
		if mysqlErr, ok := err.(*mysql.MySQLError); ok {
			if mysqlErr.Number == 1062 {
				// cardNumberId is unique
				return models.Buyer{}, httperrors.ConflictError{Message: "CardNumberId already in use"}
			}
		}
		return models.Buyer{}, err
	}

	return updatedBuyer, nil
}

// Deletes a Buyer by its id if it exists
//
// # Returns
//
// - not found if it dosent exist or a database/sql error
// - nil if the deletion was a successfull
func (r *BuyerRepositoryDB) Delete(ctx context.Context, id int) error {
	query := `
		DELETE FROM 
			buyers b
		WHERE 
			b.id = ?
	`

	result, err := r.db.ExecContext(ctx, query, id)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return httperrors.NotFoundError{Message: "Buyer not found"}
	}

	return nil
}

// get one or all buyer/s BuyerWithPurchaseOrdersCount if id is setted
// return not found if the Buyer does not exist or db error
func (r *BuyerRepositoryDB) GetWithPurchaseOrdersCount(
	ctx context.Context, id *int) ([]models.BuyerWithPurchaseOrdersCount, error) {
	query := `
	SELECT
		b.id,
		b.card_number_id,
		b.first_name,
		b.last_name,
		COUNT(po.id) as purchase_orders_count
	FROM
		buyers b
	LEFT JOIN
		purchase_orders po 
		ON po.buyer_id = b.id`

	// put the id value into an array if setted, if not, pass the array empty regardless
	params := []any{}
	if id != nil {
		query += " WHERE b.id = ?"
		params = append(params, *id)
	}

	query += `
	GROUP BY
		b.id,
		b.card_number_id,
		b.first_name,
		b.last_name
	ORDER BY b.id`

	rows, err := r.db.QueryContext(ctx, query, params...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	var buyers []models.BuyerWithPurchaseOrdersCount
	for rows.Next() {
		var buyer models.BuyerWithPurchaseOrdersCount
		err := rows.Scan(
			&buyer.Id,
			&buyer.CardNumberId,
			&buyer.FirstName,
			&buyer.LastName,
			&buyer.PurchaseOrdersCount,
		)

		// if one has an invalid field from the db, will fay the Scan
		if err != nil {
			return nil, err
		}
		buyers = append(buyers, buyer)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	// if an id was given and it didnt fetch any BuyerWithPurchaseOrdersCount
	// the buyer does not exist
	if id != nil && len(buyers) == 0 {
		return nil, httperrors.NotFoundError{Message: "Buyer not found"}
	}
	return buyers, nil
}
